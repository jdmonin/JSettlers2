/**
 * Java Settlers - An online multiplayer version of the game Settlers of Catan
 * This file Copyright (C) 2017 Ruud Poutsma <rtimon@gmail.com>
 * Portions of this file Copyright (C) 2017-2020,2022 Jeremy D Monin <jeremy@nand.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The maintainer of this program can be reached at jsettlers@nand.net
 */

syntax = "proto3";

option java_package = "soc.proto";
option optimize_for = SPEED;  // json needs proto metadata, can't use smaller/cleaner LITE_RUNTIME

// Protobuf Data structures. For messages see message.proto, game_message.proto


/* Data type for array of int32, since oneof and map can't directly contain a repeated field.
 * Negative values allowed but not frequently used (or efficiently encoded).
 */
message _IntArray { repeated int32 arr = 1; }

/* Data type for array of sint32, since oneof and map can't directly contain a repeated field.
 */
message _SIntArray { repeated sint32 arr = 1; }


//
// Game and Board Data
//

/* Board coordinates, using the same system as soc.game.SOCBoard.BOARD_ENCODING_LARGE:
 * Each hex is 2 units across and 2 units tall, oriented to have 2 vertical side edges
 * and 4 diagonal top and bottom edges.
 * Nodes are hex corners; all nodes are on even rows (0, 2, ...) running along
 * hexes' top and bottom diagonals.
 */
message NodeCoord {
    int32 row = 1;
    int32 column = 2;
}

/* All diagonal edges are on even rows; all vertical edges are on the same odd rows as
 * their hex's vertical centers. A diagonal edge's coordinates are taken from its left node:
 * edge (r=0, c=1) goes between nodes (r=0, c=1) and (r=0, c=2).
 */
message EdgeCoord {
    int32 row = 1;
    int32 column = 2;
}

/* All hexes are on odd rows; the hex's coordinate is its geometric center. */
message HexCoord {
    int32 row = 1;
    int32 column = 2;
}

/* Coordinate type to use in general messages about multiple types of pieces
 * or other things which may be located at a node, edge, or hex.
 * Use edge_coord for roads and ships, node_coord for all other PieceTypes.
 * Currently no known PieceType uses hex_coord.
 * @see PieceType
 */
message BoardCoord {
    oneof coord_type {
        NodeCoord node_coord = 1;
        EdgeCoord edge_coord = 2;
        HexCoord hex_coord = 3;
    }
}

/* Data type for list of EdgeCoord, since oneof and map can't directly contain a repeated field. */
message _EdgeList { repeated EdgeCoord edge = 1; }

/* Data type for list of HexCoord, since oneof and map can't directly contain a repeated field. */
message _HexList { repeated HexCoord hex = 1; }

/* Data type for list of NodeCoord, since oneof and map can't directly contain a repeated field. */
message _NodeList { repeated NodeCoord node = 1; }

/* Data type for list of BoardCoord, since oneof and map can't directly contain a repeated field. */
message _BoardCoordList { repeated BoardCoord coord = 1; }

/* Hex types, as in SOCBoard. Same numeric values as {@link SOCBoard#getHexTypeFromCoord(int)}. */
enum HexType {
    WATER_HEX = 0;
    /* Clay; lowest-numbered hex type. Same numeric value as ResourceType.CLAY */
    CLAY_HEX = 1;
    ORE_HEX = 2;
    SHEEP_HEX = 3;
    WHEAT_HEX = 4;
    WOOD_HEX = 5;
    DESERT_HEX = 6;
    /* Hex type for the Gold Hex, where the adjacent players choose their resource(s) every roll. */
    GOLD_HEX = 7;
    /* Hex type for the Fog Hex, with actual type revealed when roads or ships are placed. Scenario SC_FOG.
     * Bots can treat this as {@link SOCBoard#DESERT_HEX DESERT_HEX} until revealed.
     * Current maximum land hex type.
     */
    FOG_HEX = 8;
}

/* Structs here are suffixed "Data" since we eventually want them used in the java code. Many struct names will then get
the same name as its OO counterparts. As in Java OO is central, I choose to suffix the data.
 * @see ResourceSet
 */
enum ResourceType {
    // For now, we're still tied to the integer values. Therefore I want the values to be the same as we currently use
    // them until the integer dependencies are refactored out.
    _NOT_YET_USED = 0;
    CLAY = 1;
    ORE = 2;
    SHEEP = 3;
    WHEAT = 4;
    WOOD = 5;
    UNKNOWN = 6; // An unknown or hidden type of resource. TODO: shares a slot with GOLD in some instances
    // TODO maybe modernize resource names
}

/* A Set with amounts of each standard Resource Type, with optional field for other types.
 * @see ResourceType
 */
message ResourceSet {
    /* Structure to include any nonstandard resource type */
    message OtherResource {
        ResourceType res_type = 1;
        int32 amount = 2;
    }

    int32 clay  = 1;  // Amount of clay
    int32 ore   = 2;  // Amount of ore
    int32 sheep = 3;  // Amount of sheep
    int32 wheat = 4;  // Amount of wheat
    int32 wood  = 5;  // Amount of wood
    int32 unknown = 6;  // Amount of unknown/hidden type (ResourceType.UNKNOWN); allowed in only some message types like LoseResources

    // TODO maybe modernize resource names to 5th edition

    /* Optional field to include any nonstandard resource type(s) */
    repeated OtherResource others = 7;
}

/* Piece Types for {@link soc.game.SOCPlayingPiece}; same constant values as that class.
 * Used in {@link GameMessage.BuildPiece}, {@link GameMessage.CancelBuild}, etc.
 * For the resources needed to build a piece type, see {@link soc.game.SOCPlayingPiece#getResourcesToBuild(int)}.
 * @see BoardCoord
 * @see OtherPlayableItem
 */
enum PieceType {
    /* {@link soc.game.SOCRoad} */
    ROAD = 0;

    /* {@link soc.game.SOCSettlement} */
    SETTLEMENT = 1;

    /* {@link soc.game.SOCCity} */
    CITY = 2;

    /* {@link soc.game.SOCShip}; used only when {@link soc.game.SOCGame#hasSeaBoard}.
     * @since 2.0.00
     */
    SHIP = 3;

    /* {@link soc.game.SOCFortress}; used only when {@link soc.game.SOCGame#hasSeaBoard}
     * and scenario option {@link soc.game.SOCGameOption#K_SC_PIRI _SC_PIRI} active.
     * New fortresses cannot be built after the game starts.
     * @since 2.0.00
     */
    FORTRESS = 4;

    /* {@link soc.game.SOCVillage}; used only when {@link soc.game.SOCGame#hasSeaBoard}.
     * Villages belong to the game board, not to any player,
     * and new villages cannot be built after the game starts.
     * @since 2.0.00
     */
    VILLAGE = 5;
}

/* Dev Cards and other playable/cancelable player item types,
 * not built pieces like roads and settlements; used in {@link GameMessage.CancelBuild}.
 *<P>
 * This enum specifies only the general type of item, not the specific item:
 * "a development card", not "the University victory point card".
 * See specific-item types such {@link DevCardValue} for specific item details.
 *<P>
 * Before v3.0.00 these were negative numbers stored in the same fields as {@code PieceType}.
 * @see PieceType
 */
enum OtherPlayableItem {
    _UNSENT_DEFAULT_ITEM = 0;  // Required for enum, but not sent: not a valid item type
    DEV_CARD = 2;  // Development Card. See DevCardValue for each possible dev card; this item type sent from server to reject request to buy a Development Card.
    INV_ITEM = 3;  // Inventory Item. Used from client to request canceling placement of a special SOCInventoryItem if possible.
}

/* Each possible development card, some of which need specific handling or special rules (Progress cards).
 * Values 50-99 are unplayable Victory Point cards to be held until end of game.
 * Values over 100 are reserved for expansions (unplayable VP cards will be 150-199, 250-299, etc).
 * Uses new 5th-edition names, not old names (discovery, tower, temple, capitol/governor's house)
 * @see OtherPlayableItem
 */
enum DevCardValue {
    _UNSENT_DEFAULT_DEVCARDVALUE = 0;  // Required for enum, but not sent: not a valid card type
    UNKNOWN_DEV_CARD = 1;  // Unknown or undisclosed card type, for announcements to other players
    KNIGHT = 2;          // Knight / Soldier
    MONOPOLY = 3;        // Monopoly
    ROAD_BUILDING = 4;   // Road Building
    YEAR_OF_PLENTY = 5;  // Year of Plenty / Discovery
    VP_CHAPEL = 50;      // Chapel
    VP_GREAT_HALL = 51;  // Great Hall
    VP_LIBRARY = 52;     // Library
    VP_MARKET = 53;      // Market
    VP_UNIVERSITY = 54;  // University
}


//
// State and Conditions
//


/* Game state constants for {@link soc.game.SOCGame}.
 * For general docs about game states see {@link soc.game.SOCGame#NEW}.
 * Sent to client through Game_Message.State, or as a field in some other message types.
 *<P>
 * Per-state docs may eventually be transferred here from SOCGame.
 */
enum GameState {
    NEW = 0;       // New game
    READY = 1;     // Ready to start playing
    READY_RESET_WAIT_ROBOT_DISMISS = 4;  // Game reset: Waiting for bots to leave old game
    START1A = 5;   // Players place 1st settlement
    START1B = 6;   // Players place 1st road
    START2A = 10;  // Players place 2nd settlement
    STARTS_WAITING_FOR_PICK_GOLD_RESOURCE = 14;  // Gold Hex resource pick during initial placement
    START2B = 11;  // Players place 2nd road
    START3A = 12;  // Players place 3rd settlement ({@link SOCGameOption#K_SC_3IP _SC_3IP})
    START3B = 13;  // Players place 3rd road
    ROLL_OR_CARD = 15;  // Roll or play card
    PLAY1 = 20;    // Done rolling
    PLACING_ROAD = 30;
    PLACING_SETTLEMENT = 31;
    PLACING_CITY = 32;
    PLACING_ROBBER = 33;
    PLACING_PIRATE = 34;
    PLACING_SHIP = 35;
    PLACING_FREE_ROAD1 = 40;  // Player is placing their first free road/ship. If {@link soc.game.SOCGame#getCurrentDice()} == 0, the Road Building card was played before rolling the dice.
    PLACING_FREE_ROAD2 = 41;  // Player is placing their second free road/ship. If {@link soc.game.SOCGame#getCurrentDice()} == 0, the Road Building card was played before rolling the dice.
    PLACING_INV_ITEM = 42;
    WAITING_FOR_DISCARDS = 50;  // Current player must choose which resources to discard
    WAITING_FOR_ROB_CHOOSE_PLAYER = 51;  // Current player must choose a player to rob
    WAITING_FOR_DISCOVERY = 52;  // Current player must choose which 2 free resources to gain
    WAITING_FOR_MONOPOLY = 53;  // Current player must choose a resource type to monopolize
    WAITING_FOR_ROBBER_OR_PIRATE = 54;
    WAITING_FOR_ROB_CLOTH_OR_RESOURCE = 55;
    WAITING_FOR_PICK_GOLD_RESOURCE = 56;
    SPECIAL_BUILDING = 100;
    LOADING = 990;  // A saved game is being loaded
    LOADING_RESUMING = 992;  // A saved game was loaded and is about to resume, now waiting for some bots to rejoin
    OVER = 1000;  // The game is over
    RESET_OLD = 1001;  // Old game object, a new game with same name exists
}

/* Seat lock states for locking/unlocking.
 * Note different meanings while game is forming
 * (GameState NEW) versus already active.
 */
enum SeatLockState {
    /* Seat not locked.
     * If game is forming, if this seat is empty when the game starts, a bot can sit here.
     * If game is active, a newly-joining player can take over a bot in this seat.
     * Since this value is 0, it may not appear in the message ("missing" field).
     */
    UNLOCKED = 0;

    /* Seat is locked.
     * If game is forming, a bot will not sit here when the game starts.
     * If game is active, a newly-joining player can't take over a bot in this seat.
     */
    LOCKED = 1;

    /* If this active game is reset, a robot will not take this seat, it will be left vacant.
     * Useful for resetting a game to play again with fewer robots, if a robot is currently sitting here.
     * Not a valid seat lock state if game is still forming.
     *<P>
     * This feature was added in v2.0.00; before that version, the seat lock state was
     * boolean (UNLOCKED or LOCKED).  Game resets included all robots unless their seat
     * was LOCKED at the time of reset.
     */
    CLEAR_ON_RESET = 2;
}
