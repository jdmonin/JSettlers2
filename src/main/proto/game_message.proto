/**
 * Java Settlers - An online multiplayer version of the game Settlers of Catan
 * This file Copyright (C) 2017-2020,2022 Jeremy D Monin <jeremy@nand.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The maintainer of this program can be reached at jsettlers@nand.net
 */

syntax = "proto3";

option java_package = "soc.proto";
option optimize_for = SPEED;  // json needs proto metadata, can't use smaller/cleaner LITE_RUNTIME

import public "data.proto";


// Messages during play of a specific game, dispatched at server by a GameMessageHandler.
//
// A list of basic game actions and their message sequences is in
// /doc/Message-Sequences-for-Game-Actions.md .
//
// GameMessages are grouped by category. See the bottom of this file
// for GameMessageFromServer and FromClient, which use OneOf union groups.
// Those main GameMessage types are themselves sent as a OneOf field
// of the main Message.FromServer and Message.FromClient types.
//


//
// Board Layout and Contents
//

/* Board layout contents.
 * Sent when game starts or to a client who has joined a game as an observer or player,
 * after {@link SitDown} messages about current players.
 * Also sent during start of the game when its board is generated.
 * Applies to entire game (player_number field is unused).
 * TODO: Ref to list of part keynames, etc
 *
 *<H4>Optimization:</H4>
 * If the game is still forming (state NEW), client already has data for the empty board.
 * The layout message must still be sent, to set the "VS" part and other data useful for initial rendering.
 * Such an empty-board message is compact, omitting the sea hexes.
 */
message BoardLayout
{
    /* Board layout encoding format versions, from {@link soc.game.SOCBoard#getBoardEncodingFormat()} */
    enum _LayoutEncodingFormat {
        /* Required for enum, but not sent */
        _UNSENT_DEFAULT_ENCODING = 0;

        /* Not supported in JSettlers v3.x.xx: "v1" Original format : hexadecimal 0x00 to 0xFF. */
        BOARD_ENCODING_ORIGINAL = 1;

        /* Not supported in JSettlers v3.x.xx: 6-player board, variant of original format:
         * hexadecimal 0x00 to 0xFF.
         * Added in v1.1.08.
         */
        BOARD_ENCODING_6PLAYER = 2;

        /* Large sea board ({@link SOCBoardLarge}); minimum supported board encoding for v3.x.xx.
         * Coordinate range for rows, columns is each 0 to 255 decimal.
         * Arbitrary mix of land and water tiles. Activated with {@link SOCGameOption} "SBL".
         * Added in v2.0.00.
         */
        BOARD_ENCODING_LARGE = 3;
    };

    message _BoardLayoutPart {
        oneof val {
            int32 i_val = 1;    // signed integer value
            string s_val = 2;   // string value
            _IntArray i_arr = 3;  // signed integer array; negative values allowed but not frequently used
            _BoardCoordList coordinate_list = 4;  // general board coordinate list
            _EdgeList edge_list = 5;  // edge coordinate list
            _HexList hex_list = 6;    // hex coordinate list
            _NodeList node_list = 7;  // node coordinate list
        }
    }

    _LayoutEncodingFormat layout_encoding = 1;  // Board layout encoding format version

    map<string, _BoardLayoutPart> parts = 2;  // Layout Parts; some are optional depending on game options and scenario
}

/* A list of potential settlements, with optional related potential/legal position info.
 * Sent from server when game starts or client joins a game in progress.
 * This definitively sends the player's current possible placement locations, instead of having the client
 * try to infer it from the board and rules. Some seafarers scenarios have nonstandard restrictions
 * on where the players can place. By having the server be authoritative on this, more scenarios
 * could be added later without a client change.
 *<P>
 * This message is sent before any {@link BuildPiece}.
 * So even if game is in progress, each player receives their unique potential settlement node list,
 * to populate their legal node/edge sets, before seeing any of their piece locations.
 *<P>
 * Player Number field may be -1 if applies to all players at start of game.
 * -1 also indicates that the legal settlements should be set and the
 * legal roads recalculated from this message's list of potential nodes.
 *<P>
 * If the game has already started, Land Area contents are sent when
 * {@code player_number} == 0 (the first player sent) and board's legal roads should be
 * calculated at that point, before calculating any player's
 * legal or potential sets. Server typically must send several (one per player)
 * {@code PotentialSettlements} messages because of each player's unique potential/legal coordinate sets.
 * Each has the player's Potential Settlements and optional Legal Sea Edges,
 * but not the board layout's Land Areas (which are sent only with pn = 0, not again for every player).
 */
message PotentialSettlements {
    /* Potential settlement node coordinates for {@link #playerNumber}.
     * - If this field contains only a single (r=0, c=0) coordinate, treat it as empty (not as missing):
     *   This player currently has no potential settlements.
     * - If this field is missing and {@code starting_land_area} is 0, use all land areas'
     *   legal nodes as the player's potential coordinates.
     */
    repeated NodeCoord ps_nodes = 1;

    /* How many Land Areas this board has; classic boards have 1 */
    uint32 area_count = 2;

    /* Which land area number within {@link #landAreasLegalNodes} contains {@link #psNodes}?
     * 0 if none because the game already started and {@code psNodes} is unique to the player.
     * 0 if none when game is starting now and players can place anywhere.
     *<P>
     * Not used if {@link #areaCount} == 1.
     */
    uint32 starting_land_area = 3;

    /* Each land area's legal node coordinates; keys are 1 to {@link areaCount}.
     * Areas 0 and {@link #startingLandArea} are unused. All other indexes are non-null Sets.
     * Not sent if {@code areaCount} == 1.
     * From {@link soc.game.SOCBoardLarge#getLandAreasLegalNodes()}.
     */
    map<uint32, _NodeList> land_areas_legal_nodes = 4;

    /* legal sea edges per player for ships, if restricted.
     * Usually not sent, because all sea edges are legal except in scenario _SC_PIRI.
     *<P>
     * If {@link #playerNumber} != -1, {@code legalSeaEdges} contains 1 array, the legal sea edges for that player.
     * Otherwise contains 1 array for each player position (total 4 or 6 arrays).
     *<P>
     * Each per-player array is the same format as in {@code SOCBoardAtServer.PIR_ISL_SEA_EDGES}:
     * A list of individual sea edge coordinates and/or ranges.
     * Ranges are designated by a pair of positive,negative numbers:
     * 0xC04, -0xC0D is a range of the valid edges from C04 through C0D inclusive.
     * If a player position is vacant, their subarray may be empty (length 0) or contain a single zero: <tt>{ (r=0, c=0) }</tt>.
     */
    repeated _EdgeList legal_sea_edges = 5;
}

/* This message from server updates the value field(s) of a piece on the board.
 *
 *<H5>Current uses (v2.0.00):</H5>
 *<UL>
 * <LI> Cloth count for a village in the {@code SC_CLVI} cloth trade scenario
 * <LI> Fortress strength in the {@code SC_PIRI} pirate islands scenario
 *</UL>
 */
message PieceValue {
    /* Type of playing piece, like {@code VILLAGE} or {@code FORTRESS}.
     * Client can ignore this field unless the game's scenario uses values on multiple piece types.
     */
    PieceType ptype = 1;
    BoardCoord coordinates = 2;  // Coordinate of the piece
    sint32 piece_value1 = 3;  // New value for the piece
    sint32 piece_value2 = 4;  // New secondary value (if piece has 2 value fields)
}

/* Client player is asking to buy and build, or server is announcing placement of, a piece on the board.
 * Also used when joining a new game or a game in progress, to send the game state so far.
 *<P>
 * If message is from server for a {@link soc.game.SOCRoad} or {@link soc.game.SOCShip}:
 * After updating game data with the new piece, client should call {@link SOCGame#getPlayerWithLongestRoad()}
 * and update displays if needed.
 *<P>
 * If message is from server for a {@link soc.game.SOCCity} while client is joining a game, must precede
 * by sending that client a {@code BuildPiece} message with the Settlement at the same coordinate
 * which was upgraded to that city.
 *<P>
 * If this is a placement request from a client player: If successful, server announces
 * {@link PlayerElement} messages to the game for the resources spent, {@code BuildPiece},
 * and the new {@link State}. Otherwise server responds with an explanatory
 * {@code SOCDeclinePlayerRequest} or {@link GameServerText} and,
 * if the gamestate allowed placement but resources or requested coordinates
 * disallowed it, the current {@link State} and then a {@link CancelBuild}.
 * After rejection the gamestate may be a placement state such as {@code PLACING_ROAD}.
 *<P>
 * If PutPiece leads to Longest Route player changing, server sends that
 * after {@code PlayerElement}s before {@code State}: {@link GameElements}(LONGEST_ROAD_PLAYER).
 *<P>
 * Some game scenarios use {@link soc.game.SOCVillage villages} which aren't owned by any player;
 * their {@code player_number} is -1 in this message.
 *<P>
 * See also {@link MovePiece} and DebugFreePlace. Messages similar but opposite to this one
 * are {@link CancelBuild} and the very-limited {@link RemovePiece}.
 *<P>
 * Some scenarios like {@link soc.game.SOCScenario#K_SC_PIRI SC_PIRI} include some pieces
 * as part of the initial board layout while the game is starting. These will all be sent to
 * the clients while game state is &lt; {@link soc.game.SOCGame#START1A START1A} and before
 * sending them {@link StartGame}. Scenario {@link soc.game.SOCScenario#K_SC_CLVI SC_CLVI}
 * sends its neutral villages before {@code START1A} but as part {@code "CV"} of the board layout
 * message, not as {@code BuildPiece}s.
 *<P>
 * Before v3.0.00 this message was {@code SOCPutPiece}.
 *
 * @see CancelBuild
 * @see BuyInventoryItemRequest
 */
message BuildPiece {
    PieceType ptype = 1;

    /* The piece's edge, node, or hex coordinate.
     * See data.BoardCoord doc for which types set which field
     * (edge_coord or node_coord).
     */
    BoardCoord coordinates = 2;
}

/* This message from client means that the client player wants to buy a development card.
 * Some future scenario or expansion might also use it to request buying other inventory items.
 *<P>
 * During game state {@code PLAY1}, this is a normal buy request.
 * When sent during other game states, and other players' turns, this is a request
 * to start the 6-player Special Building Phase.
 *<P>
 * If the player can buy a card, the server responds with:
 *<UL>
 * <LI> Announce game data to entire game:
 *  <UL>
 *   <LI> Resource cost paid: {@link PlayerElements}
 *          (gaName, playerNumber, {@link PlayerElement#LOSE}, {@link SOCDevCard#COST})
 *   <LI> New remaining card count: {@link GameElements}
 *          (gaName, DEV_CARD_COUNT, remainingUnboughtCount)
 *  </UL>
 * <LI> Action announcement/display:
 *  <UL>
 *   <LI> Detail to the client: {@link InventoryItemAction}(DRAW, {@link SOCDevCardConstants cardTypeConstant})
 *   <LI> To all other players: {@link InventoryItemAction}(DRAW, {@link SOCDevCardConstants#UNKNOWN})
 *   <LI> Action announcement to entire game: {@link SimpleAction}
 *          (gaName, playerNumber, DEVCARD_BOUGHT, remainingUnboughtCount, 0)
 *   <LI> New {@code gameState}, to entire game: {@link State}.
 *        Usually unchanged; sent in case buying the card ended the game or otherwise changed its state.
 *        This is sent via {@link soc.server.SOCGameHandler#sendGameState(soc.game.SOCGame)},
 *        which may also send other messages depending on the gameState.
 *  </UL>
 *</UL>
 *<P>
 * If there are no cards remaining to buy, or player doesn't have enough resources,
 * isn't currently their turn, or the player otherwise can't buy a card right now,
 * the server will send them a text response or {@code SOCDeclinePlayerRequest}
 * denying the buy. Instead of that,
 * robot clients will be sent a {@link CancelBuild} message.
 *<P>
 * Before v3.0.00 this message was {@code SOCBuyDevCardRequest} and
 * {@code SOCInventoryItemAction(action = BUY)}.
 *
 * @see CancelBuild
 */
message BuyInventoryItemRequest {
    /* True if not requesting a Dev Card, but instead want to buy a generic inventory item */
    bool is_not_dev_card = 1;

    /* The type of generic inventory item, from {@link SOCInventoryItem#itype},
     * if player has any choice of which type to buy. For Dev Card, omit this field.
     */
    sint32 other_inv_item_type = 2;
}

/* Client player request, or server announcement or response to client's {@link BuyInventoryItemRequest} or
 * {@link InventoryItemAction}, about Development Cards or other {@link SOCInventoryItem}s in a player's inventory.
 * Server sometimes sends to a specific player, sometimes to all other members or to entire game.
 *<P>
 * Dev Cards:
 *<P>
 * If client player can play it, server will announce the play to game with
 * {@code InventoryItemAction}({@code PLAY}, cardType),
 * {@link PlayerElement}(PLAYED_DEV_CARD_FLAG),
 * and other messages, followed by {@link State} if state changed.
 *<P>
 * If playing a {@code KNIGHT} card leads to Largest Army, server announces that
 * after {@link PlayerElement} before {@link State}: {@link GameElements}(LARGEST_ARMY_PLAYER).
 *<P>
 * If client player can't play the card, server will reply to human player with the reason
 * using {@code SOCDeclinePlayerRequest} if new enough, {@link GameServerText} otherwise,
 * or to robot with InventoryItemAction(-1, {@code CANNOT_PLAY}, cardType).
 *<P>
 * Player Number field is -1 for action type {@code CANNOT_PLAY}; see that enum value for details.
 *<P>
 * Also sent to client when they sit down to play, to give the private details of their dev card inventory.
 *<P>
 * At end of game (state {@code OVER}), server reveals players' hidden Victory Point cards by announcing an
 * InventoryItemAction(playerNumber, ADD_OLD, devCardsSet={cardType, cardType, ...})
 * for each player that has them. This is sent to all game members; a client player should ignore
 * messages about their own cards in state {@code OVER} by checking playerNumber.
 * That multiple-cardtype form (dev_cards_set != null) is currently used only at end of game.
 *<P>
 * Other Inventory Items:
 *<P>
 * Detailed message documentation location is TBD; for now see javadoc
 * of {@code soc.message.SOCInventoryItemAction}.
 *<P>
 * Before v3.0.00 this message was {@code SOCDevCardAction}, {@code SOCPlayDevCardRequest},
 * and {@code SOCInventoryItemAction}.
 */
message InventoryItemAction {
    /* Types of action to take. Each action is sent only from server,
     * not as a request from a client, except where noted.
     */
    enum _ActionType {
        /* Required for enum, but not sent */
        _UNSENT_DEFAULT_ACTION = 0;

        /* Draw/Buy: From Server, action to add a Dev Card as new
         * to player's inventory (like ADD_NEW) from the deck.
         * Acts as a hint in case the client animates Dev Card draws from the deck.
         * Otherwise equivalent to ADD_NEW.
         * Is reply to client's {@link BuyInventoryItemRequest} message.
         */
        DRAW = 1;

        /* remove as old from player's inventory (action from server or request from client).
         *<P>
         * If this is from server for a non-Dev Card item:
         * Check the {@link #isKept} flag to see if the item should be removed from inventory, or remain with state KEPT.
         * Call {@link SOCInventoryItem#isPlayForPlacement(SOCGame, int)}: If true, playing this item requires placement;
         * client receiving the message should call {@link SOCGame#setPlacingItem(SOCInventoryItem)}.
         */
        PLAY = 2;

        /* Draw/Buy: Add as new to player's inventory; not playable this turn.
         * Same as DRAW but without implying the item has just came from the Dev Card deck;
         * can be used when client player sits down to take over a robot, and is sent its
         * inventory details.
         */
        ADD_NEW = 3;

        /* Add as old to player's inventory; can be played/activated this turn if is_playable flag is set */
        ADD_OLD = 4;

        /* The bot can't play the requested card at this time.
         * This is sent only to the requesting robot, so playerNumber is always -1 in this message.
         */
        CANNOT_PLAY = 5;

        /* If some other game action or event causes an item to need placement on the board,
         * but it was never in the player's inventory, server sends {@code PLACING_EXTRA}
         * to give the item details such as {@link #itemType} and {@link #canCancelPlay}.
         * May be sent to entire game or just to the placing current player.
         *<P>
         * Play/placement rules are specific to each kind of inventory action, and the
         * {@code PLACING_EXTRA} message may be sent before a game state change or other
         * messages necessary for placement. The client handling {@code PLACING_EXTRA}
         * should call {@link SOCGame#setPlacingItem(SOCInventoryItem)} and wait
         * for those other messages. When they arrive, client can call
         * {@link SOCGame#getPlacingItem()} to retrieve the item details.
         */
         PLACING_EXTRA = 6;
    };

    _ActionType action_type = 1;

    /* Specific type of Dev Card or Inventory Item. Not used if dev_cards_set is used. */
    oneof item_value {
        /* Type of dev card, like {@link DevCardValue#ROADS} or {@link DevCardValue#UNKNOWN_DEV_CARD}.
         * If dev_cards_set is used, this field is not used.
         * See ProtoMessageBuildHelper.fromDevCardValue / .toDevCardValue methods
         */
        DevCardValue dev_card_value = 2;

        /* Type of generic inventory item, from {@link SOCInventoryItem#itype} */
        int32 other_inv_item_type = 3;
    }

    /* several dev cards, like the Victory Point cards revealed at end of game.
     * When sending 1 item, use dev_card_value or other_inv_item_type instead.
     * Flag values like is_VP are the same for all cards in the set.
     * Not usable with action PLAY or CANNOT_PLAY.
     * See ProtoMessageBuildHelper.fromDevCardValue / .toDevCardValue methods
     */
    repeated DevCardValue dev_cards_set = 4;

    // detail/flag fields for non-DevCard inventory items:

    /* Optional reason codes for the CANNOT_PLAY action, corresponding
     * to {@link SOCGame#canPlayInventoryItem(int, int)} return codes, or 0.
     */
    sint32 reason_code = 21;

    /* If true, this item being added can be played or activated.
     * Never sent for action_types PLAY or CANNOT_PLAY.
     */
    bool is_playable = 22;

    /* If true, this item being added is kept in inventory until end of game.
     * Never sent for action_types PLAY or CANNOT_PLAY.
     */
    bool is_kept = 23;

    /* If true, this item being added is worth victory points.
     * Never sent for action_types PLAY or CANNOT_PLAY.
     */
    bool is_VP = 24;

    /* If true, this item is being added and its later play or placement can be canceled:
     * See {@link SOCInventoryItem#canCancelPlay}.
     * Never sent for action_types PLAY or CANNOT_PLAY.
     */
    bool can_cancel_play = 25;

}

/* This message type has five possible meanings, depending on game state and direction sent:
 *<UL>
 *<H3>When sent from client to server:</H3>
 *<LI> During piece placement (PLACING_ROAD, PLACING_SETTLEMENT, PLACING_CITY, PLACING_SHIP, PLACING_INV_ITEM): <BR>
 *   CancelBuild means the player has changed their mind about spending resources to build a piece.
 *   Server will reply by returning the player's resources and changing game state.
 *   <P>
 *   The special inventory items in PLACING_INV_ITEM each have a different placement message, but if item placement
 *   can be canceled, use this common message type, with {@code item_type} == ({@link Data.OtherPlayableItem#INV_ITEM}).
 *   See {@link soc.game.SOCInventoryItem} for when this is allowed.
 *   If placement can't be canceled, server will reply with {@code SOCDeclinePlayerRequest}
 *   or {@link GameServerText}.
 *
 *<LI> While placing a free road or ship from Road Building dev card (PLACING_FREE_ROAD1 or PLACING_FREE_ROAD2),
 *   means the player has decided to skip placing that free road or ship,
 *   to cancel playing the card or to use just one road or ship piece. Server will reply with new game state.
 *   Or, player can end their turn ({@link EndTurn}) to cancel free road placement.
 *   <P>
 *   If canceled before placing the 1st free road or ship, server first sends
 *   {@link InventoryItemAction}(playerNum, action=ADD_OLD,
 *   dev_card_value=ROADS) to return the card to player's inventory
 *   and {@link PlayerElement}(SET, PLAYED_DEV_CARD_FLAG, false)
 *   so they can still play a dev card this turn.
 *
 *<LI> Shouldn't be sent from client during other game states.
 *   Server will reply with {@code SOCDeclinePlayerRequest} or {@link GameServerText}.
 *
 *<H3>When sent from server to a client player:</H3>
 *
 *<LI> During game startup (START1B, START2B or START3B): <BR>
 *   Sent from server, CancelBuild means the current player
 *   is undoing the placement of their initial settlement.
 *
 *<LI> During piece placement (PLACING_ROAD, PLACING_CITY, PLACING_SETTLEMENT,
 *   PLACING_FREE_ROAD1 or PLACING_FREE_ROAD2): <BR>
 *   Sent from server, CancelBuild means the player has sent
 *   an illegal {@link BuildPiece} (bad building location). Humans can probably
 *   decide a better place to put their road, but robots must cancel
 *   the build request and decide on a new plan.
 *   <P>
 *   This can also be the reply if the client sends an illegal {@link BuildPiece}
 *   or {@link BuyInventoryItemRequest} (no resources, not the right game state, etc.)
 *   or {@link MovePiece}.
 *
 *<LI> player_number field is unused.
 *</UL>
 * Before v3.0.00 this message was {@code SOCCancelBuildRequest}.
 */
message CancelBuild {
    oneof cancel_type {
        PieceType piece_type = 1;
        OtherPlayableItem item_type = 2;
    }
}

/* Client player is asking to move, or server is announcing a move of,
 * a piece on the board to a new location.
 *<H3>From Server:</H3>
 * The client should also print a line of text such as "* Joe moved a ship."
 *<P>
 * If MovePiece leads to Longest Route player changing, server sends that after its MovePiece message:
 * {@link GameElements}(LONGEST_ROAD_PLAYER).
 *<H3>From Client:</H3>
 * The server will reply to all players with {@link MovePiece} if piece can be moved,
 * or reply to the requesting client with {@link CancelBuildRequest}.
 *<P>
 * Before v3.0.00 this message was {@code SOCMovePieceRequest} and {@code SOCMovePiece}.
 */
message MovePiece {
    /* Type of playing piece; only {@code SHIP} so far */
    PieceType ptype = 1;
    BoardCoord from_coordinates = 2;
    BoardCoord to_coordinates = 3;
}

/* This message from server announces a {@link soc.game.SOCShip} removed from the board.
 * Ships are removed when the player makes an attack on their Pirate Fortress and fails to win.
 * Currently, no other piece types are removed in any scenario, but the message allows for other types
 * in case that changes in a later version.
 *<P>
 * Introduced in v2.0.00 for the pirate islands scenario (_SC_PIRI).
 */
message RemovePiece {
    /* Type of playing piece; only {@code SHIP} so far */
    PieceType ptype = 1;
    BoardCoord coordinates = 2;
}

/* This message from server reveals a hex previously hidden by fog on the large sea board.
 * Hexes are revealed by placing roads or ships that touch a corner of a fog hex.
 * This message is sent out before the {@link BuildPiece} or {@link MovePiece} for the road
 * or ship, to reveal the hex so the piece message can update players' potential placement edge sets.
 * Client should call {@link soc.game.SOCGame#revealFogHiddenHex(int, int, int)}.
 *
 * Used with game option/scenario SC_FOG.
 */
message RevealFogHex {
    HexCoord coord = 1;   // Coordinate of the hex to reveal
    HexType htype = 2;     // Revealed hex type, same value as {@link SOCBoard#getHexTypeFromCoord(int)}
    sint32 dice_num = 3;  // Revealed hex dice number, same value as {@link SOCBoard#getNumberOnHexFromCoord(int)}, or 0/omitted
}


//
// Game and Player State
//

/* The current state of the game, sent when it changes.
 * Applies to entire game (player_number field is unused).
 *<P>
 * Messages which change the current turn or player, like {@link Turn}
 * and {@link StartGame}, include the new turn's state as a field because
 * the current player and game state are both changing.
 *<P>
 * For some states, such as {@link Data.GameState#WAITING_FOR_ROB_CHOOSE_PLAYER},
 * another message (such as {@link ChoosePlayer}) will
 * follow to prompt the current player.  For others, such as
 * {@link Data.GameState#WAITING_FOR_DISCOVERY} or
 * {@link Data.GameState#WAITING_FOR_ROBBER_OR_PIRATE}, sending this
 * State message implies that the player must decide and respond.
 * See the state list below for details.
 *<P>
 * States sent by this message, and messages sent afterwards/client response expected:
 *<UL>
 * <LI>{@code NEW}: -
 * <LI>{@code READY}: -
 * <LI>{@code READY_RESET_WAIT_ROBOT_DISMISS}: -
 * <LI>{@code START1A}: Current player: Place a settlement
 *     (all placement requests from clients are sent using {@link BuildPiece})
 * <LI>{@code START1B}: Current player: Place a road
 * <LI>{@code START2A}: Current player: Place a settlement
 * <LI>{@code START2B}: Current player: Place a road
 * <LI>{@code START3A}: Current player: Place a settlement
 * <LI>{@code START3B}: Current player: Place a road
 * <LI>{@code STARTS_WAITING_FOR_PICK_GOLD_RESOURCE}:
 *     Server sends game a "x, y, and z need to pick resources from the gold hex" prompt text.
 *     Sends the game
 *     {@link PlayerElement}({@link _PlayerElementType#NUM_PICK_GOLD_HEX_RESOURCES NUM_PICK_GOLD_HEX_RESOURCES}).
 *     Sends specific player(s) {@link SimpleRequest}({@link SimpleRequest#PROMPT_PICK_RESOURCES PROMPT_PICK_RESOURCES}).
 * <LI>{@code ROLL_OR_CARD}: Server sends game {@link DiceRollRequest} with current player number.
 *     Current player: Send {@link DiceRollRequest} or {@link InventoryItemAction}
 * <LI>{@code PLAY1}: Current player: Build, play and buy cards, trade, etc.
 *     When done with turn, send {@link EndTurn}
 * <LI>{@code PLACING_ROAD}: Current player: Place a road
 * <LI>{@code PLACING_SETTLEMENT}: Current player: Place a settlement
 * <LI>{@code PLACING_CITY}: Current player: Place a city
 * <LI>{@code PLACING_ROBBER}: Current player: Choose a new robber hex and send {@link MoveRobber}
 * <LI>{@code PLACING_PIRATE}: Current player: Choose a new pirate hex and send {@link MoveRobber}
 * <LI>{@code PLACING_SHIP}: Current player: Place a ship
 * <LI>{@code PLACING_FREE_ROAD1}: Current player: Place a road or ship
 * <LI>{@code PLACING_FREE_ROAD2}: Current player: Place a road or ship
 * <LI>{@code PLACING_INV_ITEM}: Current player: Place the previously-designated
 *     {@link soc.game.SOCInventoryItem}. Their placement message to server depends on the scenario and item type,
 *     documented at {@link InventoryItemAction}. For example, in scenario SC_FTRI the player sends a
 *     {@link SimpleRequest}({@link SimpleRequest#TRADE_PORT_PLACE TRADE_PORT_PLACE})
 *     with the requested edge coordinate; the messages responding to that are documented
 *     at {@link SimpleRequest#TRADE_PORT_PLACE}.
 *     <BR>
 *     Placement of some item types can sometimes be cancelled by sending
 *     {@link CancelBuild} with an item_type field instead.
 * <LI>{@code WAITING_FOR_DISCARDS}: Server sends game a "x, y, and z need to discard"
 *     prompt text. Players who must discard are sent a {@link LoseResources} request and must
 *     respond with {@link LoseResources}. After each client response, if still waiting for other players to discard,
 *     server sends game the same {@link State}(WAITING_FOR_DISCARDS) and another prompt text.
 *     Otherwise sends game its new {@link State}.
 * <LI>{@code WAITING_FOR_ROB_CHOOSE_PLAYER}:
 *     Server sends current player {@link ChoosePlayer} listing possible victims.
 *     Current player: Choose a victim to rob, send {@link ChoosePlayer}
 * <LI>{@code WAITING_FOR_DISCOVERY}:
 *     Current player: Choose 2 resources and send {@link GainResources}
 * <LI>{@code WAITING_FOR_MONOPOLY}:
 *     Current player: Choose a resource type and send {@link ChooseResourceType}
 * <LI>{@code WAITING_FOR_ROBBER_OR_PIRATE}:
 *     Current player: Choose whether to move the Robber or the Pirate,
 *     send {@link ChoosePlayer}({@link ChoosePlayer#CHOICE_MOVE_ROBBER CHOICE_MOVE_ROBBER} or
 *     {@link ChoosePlayer#CHOICE_MOVE_PIRATE CHOICE_MOVE_PIRATE})
 * <LI>{@code WAITING_FOR_ROB_CLOTH_OR_RESOURCE}:
 *     Current player: Choose a victim to rob and whether to take a resource or cloth, send {@link ChoosePlayer}.
 *     See that message's javadoc for how to encode both choices
 * <LI>{@code WAITING_FOR_PICK_GOLD_RESOURCE}:
 *     Same message flow as {@code WAITING_FOR_DISCARDS}: Server sends game a
 *     "x, y, and z need to pick resources from the gold hex" prompt text.
 *     When receiving this state from server, a client shouldn't immediately check their user player's
 *     {@link SOCPlayer#getNeedToPickGoldHexResources()} or prompt the user to pick resources.
 *     For each player who must pick, the game is sent
 *     {@link PlayerElement}({@link _PlayerElementType#NUM_PICK_GOLD_HEX_RESOURCES NUM_PICK_GOLD_HEX_RESOURCES})
 *     and the player is sent
 *     {@link SimpleRequest}({@link SimpleRequest#PROMPT_PICK_RESOURCES PROMPT_PICK_RESOURCES}).
 *     They must choose resource(s) and send {@link GainResources}.
 *     After each client response, server sends game its {@link State}; if multiple players had to pick,
 *     that state is still {@code WAITING_FOR_PICK_GOLD_RESOURCE} and another "need to pick" prompt text is also sent.
 * <LI>{@code SPECIAL_BUILDING}: Current player: Build, buy cards, etc. When done, send {@link EndTurn}
 * <LI>{@code LOADING}: -
 * <LI>{@code LOADING_RESUMING}: -
 * <LI>{@code OVER}: Server announces the winner with
 *     {@link GameElements}(CURRENT_PLAYER) (or {@link Turn} instead of {@link State}),
 *     and sends text messages reporting
 *     winner's name, final score, each player's victory-point cards, game length, and a {@link GameStats}.
 *     Each player is sent text with their resource roll totals. win-loss count for this session, and
 *     how long they've been connected.
 *     See {@link GameStats} for sequence details.
 *</UL>
 * This list doesn't mention some informational/cosmetic text messages, such as the {@code START1A}
 * prompt "It's Joe's turn to build a settlement" or {@code PLACING_ROBBER}'s "Lily will move the robber".
 *<P>
 * Before v3.0.00 this message was {@code GameState}.
 */
message State {
    GameState state = 1;
}

/* Action types for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementAction {
    _UNSENT_DEFAULT_ACTION = 0;  // Required for enum, but not sent: not a valid action type
    SET  = 1;  // Set element to value
    GAIN = 2;  // Add value to element
    LOSE = 3;  // Subtract value from element
}

/* Player element types for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementType {
    /* Required for enum, but not sent: not a valid player element. Not to be confused with {@link #ELEM_UNKNOWN_RESOURCE}. */
    _UNSENT_DEFAULT_PLAYER_ELEM = 0;

    /*
     * player element types (1-5). CLAY has same value
     * as {@link Data.ResourceType#CLAY_VALUE};
     * ORE, SHEEP, WHEAT and WOOD also match Data.ResourceType.
     * and {@code SOCResourceConstants}.
     */
    ELEM_CLAY = 1;
    ELEM_ORE = 2;
    ELEM_SHEEP = 3;
    ELEM_WHEAT = 4;
    ELEM_WOOD = 5;

    /*
     * Amount of resources of unknown type; sent in messages about opponents' resources.
     * For some loops which send resource types + unknown, this constant is assumed to be 6
     * (5 known resource types + 1).
     *<P>
     * Before sending this from server, check if game option {@link soc.game.SOCGameOptionSet#K_PLAY_FO PLAY_FO} is set:
     * May want to send as known resource type instead.
     *<P>
     * Not to be confused with {@link #_UNSENT_DEFAULT_PLAYER_ELEM}.
     * @see #RESOURCE_COUNT
     */
    ELEM_UNKNOWN_RESOURCE = 6;

    /* Number of Road pieces available to place. */
    ROADS = 10;

    /* Number of Settlement pieces available to place. */
    SETTLEMENTS = 11;

    /* Number of City pieces available to place. */
    CITIES = 12;

    /*
     * Number of Ship pieces available to place.
     * @since 2.0.00
     */
    SHIPS = 13;

    /*
     * Number of knights in player's army; sent after a Soldier card is played.
     *<P>
     * If playing a KNIGHT card leads to Largest Army, server announces with
     * {@link GameElements}(LARGEST_ARMY_PLAYER})
     * after {@code PlayerElement}(PLAYED_DEV_CARD_FLAG) before {@code State}.
     *<P>
     * During normal gameplay, "largest army" indicator at client is updated
     * by examining game state, not by {@link GameElements._ElementType#LARGEST_ARMY_PLAYER} message from server:
     *<BR>
     * Client should update player's number of knights with {@link SOCPlayer#setNumKnights(int)},
     * then game's largest army by calling {@link SOCGame#updateLargestArmy()},
     * then update any related displays.
     */
    NUMKNIGHTS = 15;

    /*
     * For the 6-player board, player element type for asking to build
     * during the {@link soc.game.SOCGame#SPECIAL_BUILDING Special Building Phase}.
     * This element is {@code SET} to 1 or 0.
     *<P>
     * Also used by {@link soc.server.savegame.SavedGameModel}, omitted when value is 0.
     * @see #HAS_SPECIAL_BUILT
     * @since 1.1.08
     */
    ASK_SPECIAL_BUILD = 16;

    /*
     * Total resources this player has available in hand to use.
     * Sent only with {@code SET}, not {@code GAIN} or {@code #LOSE}.
     *<P>
     * Alternately, send that info as part of a {@link DiceResultResources} message.
     * @see #UNKNOWN_RESOURCE
     * @since 2.0.00
     */
    RESOURCE_COUNT = 17;

    /*
     * Node coordinate location of this player's most recently placed settlement, or 0.
     * Used for robots during initial placement at the start of a game.
     * Sent only with {@code SET}, not {@code GAIN} or {@code #LOSE}.
     * @since 2.0.00
     */
    LAST_SETTLEMENT_NODE = 18;

    /*
     * Has this player played a development card already this turn?
     * Applies to all players if {@code playerNumber} == -1.
     * This element is {@code SET} to 1 or 0, never sent with {@code GAIN} or {@code #LOSE}.
     * @since 2.0.00
     */
    PLAYED_DEV_CARD_FLAG = 19;

    /*
     * Is {@link SOCPlayer#getNeedToDiscard()} true?
     * This element is 1 if so, otherwise 0 or omitted.
     *<P>
     * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel}.
     * Clients are sent {@link LoseResources} instead.
     *
     * @since 2.3.00
     */
    DISCARD_FLAG = 20;

    /*
     * In 6-player game's Special Building Phase, has the player already Special Built this turn?
     * From {@link SOCPlayer#hasSpecialBuilt()}.
     * This element is 1 or 0.
     *<P>
     * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel}
     * when gameState is SPECIAL_BUILDING.
     *
     * @see #ASK_SPECIAL_BUILD
     * @since 2.3.00
     */
    HAS_SPECIAL_BUILT = 21;

    /*
     * Dev card stats: Value of {@link SOCPlayer#numDISCCards}.
     *<P>
     * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel} when value > 0.
     * @since 2.5.00
     */
    NUM_PLAYED_DEV_CARD_DISC = 22;

    /*
     * Dev card stats: Value of {@link SOCPlayer#numMONOCards}.
     *<P>
     * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel} when value > 0.
     * @since 2.5.00
     */
    NUM_PLAYED_DEV_CARD_MONO = 23;

    /*
     * Dev card stats: Value of {@link SOCPlayer#numRBCards}.
     *<P>
     * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel} when value > 0.
     * @since 2.5.00
     */
    NUM_PLAYED_DEV_CARD_ROADS = 24;

    //
    // Elements related to scenarios and sea boards:
    //

    /*
     * For the {@link soc.game.SOCBoardLarge large sea board},
     * player element type for asking to choose
     * resources from the gold hex after a dice roll,
     * during the {@link soc.game.SOCGame#WAITING_FOR_PICK_GOLD_RESOURCE WAITING_FOR_PICK_GOLD_RESOURCE}
     * game state.
     * This element is {@code SET} to 0 or to the number of resources to choose.
     * Call {@link soc.game.SOCPlayer#setNeedToPickGoldHexResources(int)}.
     * @since 2.0.00
     */
    NUM_PICK_GOLD_HEX_RESOURCES = 101;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * the player's number of Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's
     * {@link soc.game.SOCPlayer#getSpecialVP()}.
     * @since 2.0.00
     */
    SCENARIO_SVP = 102;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of flags related to scenario player events.
     * This element is {@code SET} to 0 or to the player's flags
     * from {@link soc.game.SOCPlayer#getScenarioPlayerEvents()}.
     * @since 2.0.00
     */
    SCENARIO_PLAYEREVENTS_BITMASK = 103;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of land areas for tracking Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's land areas
     * from {@link soc.game.SOCPlayer#getScenarioSVPLandAreas()}.
     * @since 2.0.00
     */
    SCENARIO_SVP_LANDAREAS_BITMASK = 104;

    /*
     * Player's starting land area numbers, from {@link soc.game.SOCPlayer#getStartingLandAreasEncoded()}.
     * Sent only at reconnect, because these are also tracked during play at the client.
     * Sent as <tt>(landArea2 &lt;&lt; 8) | landArea1</tt>.
     *<P>
     * Server will also send this at the end of initial placement if
     * game is using a scenario like {@link soc.game.SOCScenario#K_SC_TTD SC_TTD} which uses
     * {@link soc.server.SOCBoardAtServer#getBonusExcludeLandArea()} (an uncommon situation).
     * @since 2.0.00
     */
    STARTING_LANDAREAS = 105;

    /*
     * For scenario <tt>_SC_CLVI</tt> on the {@link soc.game.SOCBoardLarge large sea board},
     * the number of cloth held by this player.
     * This element is {@code SET} to 0 or to the player's cloth count
     * from {@link soc.game.SOCPlayer#getCloth()}.
     * After giving cloth to a player, check their total VP; 2 cloth = 1 Victory Point.
     *<P>
     * The board's "general supply" is updated with this element type
     * with {@link #getPlayerNumber()} == -1.
     * Each village's cloth count is updated with a {@link SOCPieceValue PIECEVALUE} message.
     * @since 2.0.00
     */
    SCENARIO_CLOTH_COUNT = 106;

    /*
     * For scenario game option <tt>_SC_PIRI</tt>,
     * the player's total number of ships that have been converted to warships.
     * See SOCPlayer.getNumWarships() for details.
     * This element can be {@code SET} or {@code GAIN}ed.  For clarity, if the number of
     * warships decreases, send {@code SET}, never send {@code LOSE}.
     * {@code GAIN} is sent only in response to a player's successful
     * {@link InventoryItemAction} to convert a ship to a warship.
     *<P>
     * If a player is joining a game in progress, the <tt>PLAYERELEMENT(SCENARIO_WARSHIP_COUNT)</tt>
     * message is sent to their client only after sending their SOCShip piece positions.
     * @since 2.0.00
     */
    SCENARIO_WARSHIP_COUNT = 107;
}

/*
 * This message from the server conveys one part of a player's status,
 * such as their number of settlements remaining.
 *<P>
 * Unless otherwise mentioned, any {@code elementType} can be sent with
 * any action ({@link _PlayerElementAction#SET}, {@link _PlayerElementAction#GAIN GAIN},
 * {@link _PlayerElementAction#LOSE LOSE}).
 *<P>
 * Player Number: Some element types can use -1 for all players, some others don't use that field.
 * See _PlayerElementType for details.
 *
 *<H3>Message Sequence:</H3>
 *<UL>
 * <LI> For a bank trade (server response to player's {@link TradeWithBank}),
 *   all the {@code LOSE} messages come before the {@code GAIN}s.
 * <LI> For trade between players ({@link TradeAcceptOffer}), the {@code LOSE}s and {@code GAIN}s
 *   are interspersed to simplify server code.
 * <LI> When dice roll result is 7 and player(s) must discard, server announces
 *   game state {@link Data.GameState#WAITING_FOR_DISCARDS}, then prompts individual players to discard;
 *   see {@link DiceResult} docs for more of that sequence.
 *   Once a players's chosen their resources to discard, server announces they've done so
 *   with a {@code PlayerElement}(playerNum, LOSE}, UNKNOWN_RESOURCE, total)</tt>
 *   while game is still in state {@code WAITING_FOR_DISCARDS}; any {@code LOSE} message in that
 *   game state is for a discard.
 * <LI> Most other situations send single PlayerElement messages or their sequence doesn't matter.
 *</UL>
 *<P>
 * Resource loss can be expected and good (buying pieces or trading with other players)
 * or unexpected and bad (monopoly, robber, discards). v1.2.00 and newer have sound effects
 * to announce unexpected gains or losses; to help recognize this, this message type has a
 * {@link #isNews()} flag field.
 *<P>
 * To use less overhead to send multiple similar element changes, use {@link PlayerElements} instead.
 */
message PlayerElement {
    _PlayerElementAction action = 1;
    _PlayerElementType element_type = 2;
    sint32 amount = 3;
    bool is_news = 4;
}

/*
 * This message from the server holds information on some parts of a player's status,
 * such as resource type counts.  Same structure as {@link PlayerElement} but with
 * less overhead to send multiple similar element changes.
 *<P>
 * Player Number: Some element types can use -1 for all players, some others don't use that field.
 * See _PlayerElementType for details.
 *<P>
 * For a given player number and action type, contains parallel lists for sending
 * (element type, amount) pairs.
 *<P>
 * Unlike {@link PlayerElement}, has no "is_news" flag (client treats as if flagged false).
 *<P>
 * Defined in v1.1.09 but unused before v2.0.00.
 */
message PlayerElements {
    _PlayerElementAction action = 1;
    repeated _PlayerElementType element_types = 2;
    repeated sint32 amounts = 3;
}

/* This message from the server sets or updates fields of a game's status,
 * such as the number of rounds played or development cards available.
 *<P>
 * Applies to entire game (player_number field is unused).
 * @since 2.0.00
 */
message GameElements {

    enum _ElementType {
        /* Required for enum, but not sent: not a valid game element */
        _UNSENT_DEFAULT_GAME_ELEM = 0;

        /* Current round of play, from {@link soc.game.SOCGame#getRoundCount()}. */
        ROUND_COUNT = 1;

        /* Number of development cards remaining in the deck to be bought,
         * from {@link soc.game.SOCGame#getNumDevCards()}.
         *<P>
         * Sent to clients during game join/start.
         *<P>
         * When a dev card is bought, server sends {@link SOCSimpleAction}(DEVCARD_BOUGHT)'s
         * remaining-card count field instead: See {@link BuyInventoryItemRequest} javadoc.
         */
        DEV_CARD_COUNT = 2;

        /* Player number of first player in this game, from {@link soc.game.SOCGame#getFirstPlayer()}. */
        FIRST_PLAYER = 3;

        /* Player number of current player, or -1, from {@link soc.game.SOCGame#getCurrentPlayerNumber()}. */
        CURRENT_PLAYER = 4;

        /* Player number of player with Largest Army, or -1, from {@link soc.game.SOCGame#getPlayerWithLargestArmy()}.
         * Sent when a client joins a game, and when changes occur during normal gameplay
         * in response to a player's {@link InventoryItemAction}(PLAY, KNIGHT).
         */
        LARGEST_ARMY_PLAYER = 5;

        /* Player number of player with Longest Road/Route, or -1, from {@link soc.game.SOCGame#getPlayerWithLongestRoad()}.
         * Sent when a client joins a game, and when changes occur during normal gameplay
         * in response to a player's {@link BuildPiece}, {@link MovePiece}, or DebugFreePlace.
         */
        LONGEST_ROAD_PLAYER = 6;

        /* During 6-player game's Special Building Phase,
         * the value of {@link SOCGame#getSpecialBuildingPlayerNumberAfter()}.
         *<P>
         * Not sent to clients over network; used only by {@link soc.server.savegame.SavedGameModel}
         * when gameState is {@link Data.GameState#SPECIAL_BUILDING}.
         */
        SPECIAL_BUILDING_AFTER_PLAYER = 7;
    }

    repeated _ElementType element_types = 1;
    repeated sint32 values = 2;
}


//
// Current Turn
//

/* From client, this message means that a player wants to start the game;
 * from server, it means that a game has just started, leaving state {@code NEW}.
 * Applies to entire game (player_number field is unused).
 * First player number will be announced soon with a {@link Turn}.
 *<P>
 * This message optionally includes a {@code state} field
 * instead of a separate {@link State} message, since the state is part of the Start Game transition.
 *<P>
 * If a client joins a game in progress it won't be sent a {@code StartGame} message,
 * only the game's current {@code GameState} and other parts of the game's and
 * players' current status: See {@link JoinGame}.
 */
message StartGame {
    GameState state = 1;  // new state; ignored from client
}

/* End of the current player's turn, start of a new turn.
 * Client should end current turn, set current player number and game state,
 * then clear dice, reset votes, etc by calling {@link SOCGame#updateAtTurn()}.
 * When client receives this message,
 * {@link SOCGame#updateAtTurn()} will clear the new player's {@link SOCPlayer#hasPlayedDevCard()} flag.
 * New player's client should check the state field to inform that player's options and actions.
 *<P>
 * Applies to entire game: player_number is the new current player's seat number.
 *<P>
 * During Special Building (SBP) server doesn't follow this message
 * with {@link GameServerText}("Special building phase: Lily's turn to place"); client should print
 * a prompt like that when it receives {@code Turn}(SPECIAL_BUILDING).
 *<P>
 * Is also sent to game during initial placement when a round ends,
 * since the direction of play changes, and player has just placed a road or ship and should now place
 * the next settlement or roll the dice to start the game's first turn of regular play.
 *<P>
 * Also sent at game state {@link Data.GameState#OVER} to confirm the winning player,
 * who will already be the current player.
 *<P>
 * Also can be sent to a client joining a game in progress, to set only the current player number.
 * In this case {@code state} will be empty or 0. Before v3.0.00 this usage was a separate
 * {@code SOCSetTurn} message type.
 */
message Turn {
    GameState state = 1;  // new state, or empty/0 when joining game in progress
}

/* This message from server to client says whose turn it is.
 * Only the game's current player number should change; no other
 * game state is updated.
 *<P>
 * Applies to entire game: player_number is the new current player's seat number.
 */
message SetTurn {
    // No detail fields are needed beyond GameMessageFromServer.player_number
}

/* Prompt from server to entire game telling the current player to roll dice,
 * or request from that client player to roll.
 *<P>
 * From server, includes player number being prompted to roll.
 * Currently this is always the current player; in some future expansion
 * it could be a different player.
 *<P>
 * Before v3.0.00 this message was {@code SOCRollDicePrompt} and {@code SOCRollDice}.
 */
message DiceRollRequest {
    // No detail fields are needed beyond GameMessageFromServer.player_number
}

/* Reports the total of what was rolled on the dice this turn.
 * The two individual dice amounts can be reported in a text message.
 * Applies to entire game (player_number field is unused).
 *<P>
 * This is in response to a client player's {@link DiceRollRequest}.
 * Will sometimes be followed with various messages to entire game and/or
 * to some players, depending on the roll results and scenario/rules in effect.
 * The last data message of sequence sent to entire game is always {@link State}
 * (rolling a 7 might lead to discards or moving the robber, etc.).
  *<P>
 * The guideline is that the "public" sequence ends with the new game state message,
 * then any new state text for human clients, then any prompt for action
 * sent to individual player clients in the new state.
 * Any special resource (cloth) distributed as roll results, or any report of action happening
 * (fleet battle lost/won), is sent before the state message.
 *
 *<H4>Sequence details</H4>
 *
 * When players gain resources on the roll, game members will be sent {@link DiceResultResources}.
 *<P>
 * Each player who gained resources on the roll is sent their currently
 * held amounts for each resource as {@link PlayerElements}(SET, resType, amount) messages
 * for all their new resource counts.
 * When client receives such a 5-element {@link PlayerElements} in state {@code ROLL_OR_CARD},
 * they may want to clear their Unknown resource amount to 0 in case it has drifted.
 *<P>
 * When 7 is rolled and players must discard, then instead, {@code DiceResult}
 * is followed by a {@link State}({@code WAITING_FOR_DISCARDS}) announcement,
 * then a {@link LoseResources} prompt to each affected player.
 * See {@link LoseResources} for player response and the next part of that sequence.
 *
 *<H4>End of sequence</H4>
 *
 * As noted above, the message sequence to the entire game always ends with {@code State}.
 * That might be followed with {@link GameServerText} for human players to read,
 * and/or messages sent privately to a player such as {@link LoseResources}
 * (which doesn't need to be "public" because entire game knew the number of cards held
 * when the 7 was rolled).
 */
message DiceResult {
    /* Total rolled on both dice, 0 at start of turn,
     * or -1 at start of game; see SOCGame.getCurrentDice()
     */
    sint32 dice_total = 1;
}

/* All resources gained by players from a dice roll, and their new resource totals.
 * Announced to all game members after a {@link DiceResult} where players gain resources.
 * Applies to entire game (player_number field is unused).
 */
message DiceResultResources {
    /* One player's gained resource types, amounts, and totals. */
    message PlayerResources {
        uint32 player_number = 1;    // Player number gaining resources
        ResourceSet res_gained = 2;  // Type and amount of resources gained
        uint32 res_total = 3;        // Player's new total resource count
    }

    repeated PlayerResources player_resources = 1;
}

/* Player wants to end their turn; a request sent from client, not an announcement from server. */
message EndTurn {
    // no detail fields are needed
}


//
// Player Info
//


//
// Player Actions
//

// TODO simple request
// TODO simple action


//
// Player Actions: Trade
//

/* Client is making, or server is announcing, a bank trade or port trade.
 * Also used to undo player's previous trade (swap previous give/get resource sets).
 *<P>
 * If the client's trade request is acceptable, server responds to entire game with
 * {@code TradeWithBank} to announce the trade details.
 *<P>
 * TThe server disallows any unacceptable trade by sending the client a
 * {@code TradeRejectOffer} with a reason code like {@code REASON_NOT_YOUR_TURN}.
 *<P>
 * Before v3.0.00 this message was SOCBankTrade.
 * @see TradeMakeOffer
 */
message TradeWithBank {
    ResourceSet give = 1;
    ResourceSet get  = 2;
}

/* Client is making, or server is announcing, a trade offer.
 * Other player clients may respond with TradeRejectOffer or TradeAcceptOffer.
 *<P>
 * player_number is the player offering this trade to some or all other players.
 *<P>
 * If this trade offer is disallowed, server replies with a {@link TradeRejectOffer}
 * with reason REASON_CANNOT_MAKE_OFFER.
 *<P>
 * Before v3.0.00 this message was SOCMakeOffer.
 * @see TradeWithBank
 * @see TradeClearOffer
 */
message TradeMakeOffer {
    ResourceSet give = 1;
    ResourceSet get  = 2;
    _IntArray to_players = 3;  // only needed if offer is not to all other player numbers (not only seated ones)
    int32 offer_serial = 4;  // optional offer number assigned by server, or 0 if server has not done so; ignored from client
}

/* A the player is retracting an offer.
 * Or, server wants any trade messages/responses cleared in the client UI
 * at end of turn or after {@link TradeAcceptOffer}.
 *<P>
 * player_number can be -1 to clear all offers by all players.
 * @see TradeMakeOffer
 */
message TradeClearOffer {
    // No detail fields are needed beyond GameMessageFromServer.player_number
}

/* Typically this message means that the player is rejecting all offers ("no thanks").
 * Server can also send it with a "reason code" when rejecting a client's trade-related request
 * (player trade or bank trade).
 *
 *<H3>Typical usage: (without a reason code)</H3>
 *
 * Sent from rejecting player's client to server.
 * The server then sends a copy of the message to all players
 * to announce the rejection.
 *<UL>
 * <LI> Message to server is client player's response to a {@link SOCMakeOffer} sent earlier this turn.
 * <LI> Followed by (from server, to all clients) {@link TradeRejectOffer} with the same data.
 *</UL>
 *
 *<H3>With a reason code:</H3>
 *
 * Sent from server to a player's client in response to their bank trade, player trade offer,
 * or request to accept a trade, with the specific reason it was disallowed ({@link #REASON_NOT_YOUR_TURN},
 * {@link #REASON_CANNOT_MAKE_OFFER}, or generic {@link #REASON_CANNOT_MAKE_TRADE}).
 * See those constants for info about when they're used,
 * or {@link #getReasonCode()} for general info.
 *<P>
 * In a future version or fork, reason codes could also be sent from a rejecting player's client
 * to give a specific reason for the rejection. This would be mentioned in that reason code constant's
 * javadoc. Server would then announce the rejection to all players.
 *<P>
 * Before v3.0.00 this message type was SOCRejectOffer.
 * @see TradeMakeOffer
 * @see TradeAcceptOffer
 */
message TradeRejectOffer {

    /* Reason codes; added to classic message type SOCRejectOffer in v2.5.00. */
    enum _ReasonCode {
        /* Required for enum; the actual generic reason code is {@link #REASON_CANNOT_MAKE_TRADE}. */
        _UNSENT_DEFAULT = 0;

        /* Server's generic reason code when the requesting client can't offer or accept this trade now
         * for whatever reason, or make this bank trade. Usually because they don't have the right resources to give.
         * See {@link TradeRejectOffer#reason_code} for more info.
         *<P>
         * Sent in response to {@link TradeWithBank} and {@link TradeAcceptOffer}.
         * For a more specific reason, see {@link #REASON_NOT_YOUR_TURN}.
         *<P>
         * {@code player_number} is -1 if rejecting a player's port/bank trade request,
         * otherwise is the client's player number.
         * @see #REASON_CANNOT_MAKE_OFFER
         */
        REASON_CANNOT_MAKE_TRADE = 1;

        /* Server's reply reason code when the requesting client can't make this trade now
         * because it isn't their turn.
         *<P>
         * Sent in response to {@link TradeWithBank}.
         *<P>
         * {@code player_number} will be -1.
         * @see #REASON_CANNOT_MAKE_TRADE
         */
        REASON_NOT_YOUR_TURN = 2;

        /* Server's reason code when the requesting client can't make this trade offer now.
         *<P>
         * Sent in response to {@link TradeMakeOffer}, but not {@link TradeWithBank}.
         * @see #REASON_CANNOT_MAKE_TRADE
         */
        REASON_CANNOT_MAKE_OFFER = 3;
    };

    /* From server, optional reason code for why an offer was rejected by server or declined by a player;
     * not sent from client.
     */
    _ReasonCode reason_code = 1;
}

/* A player is accepting a trade offer currently made to them.
 * If sent from client and trade is allowed, server announces the received TradeAcceptOffer
 * to all clients in the game, followed by {@link TradeClearOffer}.
 *<P>
 * From server, player_number is the player accepting this trade from offering_player_number.
 *<P>
 * The server disallows any unacceptable trade by sending that "accepting" client a
 * {@code TradeRejectOffer} with reason code {@code REASON_CANNOT_MAKE_TRADE}.
 * @see TradeMakeOffer
 * @see TradeRejectOffer
 */
message TradeAcceptOffer {
    int32 offering_player_number = 1;  // player number offering the trade being accepted
    int32 offer_serial = 2;  // offer number from TradeMakeOffer, if not 0, in case of unexpected last-minute new offers
    ResourceSet resToAccepting = 3;  // resources being given to accepting player, if sent from server
    ResourceSet resToOffering  = 4;  // resources being given to offering player, if sent from server
}


//
// Player Actions: Resources and Robbing
//


/* A player picks which resources to discard or lose.
 * - First sent to client as prompt with the amount to lose.
 * - Client player responds with specific resources from their hand.
 * - If they have those resources to lose: Server replies to them
 *   with LoseResources(pn, lose), announces the total amount lost
 *   to other game members as LoseResources(pn, unknownResources).
 *   Otherwise: Server re-sends the prompt to client.
 * - Server will then send the new {@link State}.
 *   If waiting for others to discard, server also sends the game a {@link GameServerText} that lists
 *   who we're still waiting for.
 *<P>
 * Before v3.0.00 this message type was SOCDiscardRequest and SOCDiscard.
 */
message LoseResources {
    int32 amount = 1;  // prompt or announcement from server: player must lose this many resources
    ResourceSet lose = 2;  // the resources lost
}

/* A player picks which resources to gain. (Year of Plenty, Gold hex, etc).
 * - First sent to client as prompt with the amount to gain.
 * - Client player responds with specific resources they want to gain.
 * - Server announces the specific resources gained to the game.
 */
message GainResources {
    int32 amount = 1;  // prompt from server: player must pick this many resources to gain
    ResourceSet gain = 2;  // gain these resources
}

/* A player picks a resource type, typically for a Monopoly card.
 * Sent by current player client in response to GameState(WAITING_FOR_MONOPOLY).
 *<P>
 * If client isn't currently allowed to request that pick, server responds
 * with {@code SOCDeclinePlayerRequest}, or to an older client with
 * {@link GameServerText} and {@link State}.
 *<P>
 * Before v3.0.00 this message type was SOCPickResourceType.
 */
message ChooseResourceType {
    ResourceType rtype = 1;  // choose this resource type
}

/* A player chooses another player, typically to rob from.
 * This message type is used for the prompt from server,
 * and the response from client player.
 *<P>
 * In some game scenarios like {@code SC_PIRI}, the player might have the option to steal from no one
 * (see game state {@link Data.GameState.WAITING_FOR_ROB_CHOOSE_PLAYER}).
 *<P>
 * In response to a server's State({@link Data.GameState.WAITING_FOR_ROBBER_OR_PIRATE}),
 * it says whether the player wants to move the robber or the pirate ship.
 *<P>
 * In response to a server's {@link ChoosePlayer} message while in
 * game state {@link Data.GameState.WAITING_FOR_ROB_CLOTH_OR_RESOURCE},
 * it says whether the player wants to rob cloth or rob a resource from the victim.
 *<P>
 * If client isn't currently allowed to make that choice, server responds
 * with {@code SOCDeclinePlayerRequest}.
 *<P>
 * If client is allowed but their choice is wrong (player number isn't a possible victim, etc),
 * server resends {@link ChoosePlayer} to that client.
 *<P>
 * Otherwise server will respond with the results of the choice: {@link RobberyResult}, {@link State}, etc.
 */
message ChoosePlayer {
    /* From client: player number to choose, or -1 for none if allowed.
     *<P>
     * From client during game state {@link Data.GameState.WAITING_FOR_ROBBER_OR_PIRATE}:
     * -2 to move robber, or -3 to move pirate ship.
     *<P>
     * From client during game state {@link Data.GameState.WAITING_FOR_ROB_CLOTH_OR_RESOURCE}:
     * To rob a resource set this field to playerNumber as usual, to rob cloth set it to -(playerNumber + 1).
     */
    sint32 chosen_player_number = 1;

    bool can_choose_none = 2;  // from server: If true, can make a choice of "no player"
    repeated uint32 chooseable_player_number = 3;  // from server: List of player numbers who can be chosen
}

/* A player's request or server's announcement to move the robber or pirate ship.
 * - Server sends GameState(PLACING_ROBBER) or (PLACING_PIRATE)
 * - Client player responds with MoveRobber with a location to move to,
 *   and either is_robber or is_pirate flag.
 * - If player can move there, server announces the move to the game
 *   with MoveRobber and the new game state. May be followed by other messages
 *   about gaining/losing resources: {@link RobberyResult} or {@link PlayerElement}.
 *   So for this message, the client should only call {@link soc.game.SOCBoard#setRobberHex(int, boolean)}
 *   and not {@link soc.game.SOCGame#moveRobber(int, int)}.
 * - Otherwise server sends {@code SOCDeclinePlayerRequest} to the client and
 *   game state remains PLACING_ROBBER or PLACING_PIRATE.
 *<P>
 * Once the robber is placed on the board, it cannot be taken off the board.
 * The pirate can be taken off by sending {@code move_to = 0}.
 */
message MoveRobber {
    HexCoord move_to = 1;  // Move to this location, or 0 to remove pirate ship

    /* In server prompt, true if robber can be moved.
     * From client or server announcement, true if robber was moved
     * (won't also have is_pirate true).
     */
    bool is_robber = 2;

    /* In server prompt, true if pirate ship can be moved.
     * From client or server announcement, true if pirate ship was moved
     * (won't also have is_robber true).
     */
    bool is_pirate = 3;
}


//
// Game Lifecycle: Reset Board & Voting
//


/* A request from a player to reset the game board.
 * - Player client sends this to server
 * - If can't reset game at this time, server replies with ResetBoardResult(was_rejected=true)
 * - If there are no other human players, server replies with ResetBoardResult(was_rejected=false) to reset the board
 * - If there are other human players:
 *   - Server announces this ResetBoardRequest to all human players, including requesting player
 *   - Other human players are sent a ResetBoardVote prompt
 *   - For next steps after that, see ResetBoardVote docs
 */
message ResetBoardRequest {
    // No detail fields are needed beyond GameMessageFromServer.player_number
}

/* A human player's vote on whether to reset this game board.
 * - First sent to client as prompt to vote yes or no
 * - Client player responds with their vote
 * - Server announces each vote to the entire game
 * - Once all human players have voted, server announces the ResetBoardResult
 *<P>
 * Before v3.0.00 this message was SOCResetBoardVoteRequest and SOCResetBoardVote.
 */
message ResetBoardVote {
    bool is_yes = 1;  // True if this client player is voting Yes to reset the board
}

/* Result announcement from server for a board reset request/vote.
 * For a successful reset request (wasn't rejected):
 * - GameMessageFromServer.player_number is the player who asked for the reset.
 * - For human players, this message replaces the JoinGame message seen when joining a brand-new game;
 *   the reset message will be followed with others which will fill in the game state.
 * - Robots must instead discard game state and ask to re-join.
 *   Robot clients must treat this message as a BotJoinGameRequest to join the new game.
 *<P>
 * Before v3.0.00 this message was SOCResetBoardAuth and SOCResetBoardReject.
 */
message ResetBoardResult {
    bool was_rejected = 1;  // True if reset was rejected or voted down, false if the reset is starting now
}


//
// GameMessageFromServer, GameMessageFromClient: For encode/decode, a GameMessage type
// containing all other message types using OneOf. These main GameMessageFromServer
// and FromClient types are sent as a OneOf in the main Message.FromServer and FromClient.
//


message GameMessageFromServer {
    string game_name = 1;

    /* Player Number this applies to, if any. Some messages apply to the entire game
     * and don't use a player number; others may use -1 to indicate all players.
     * Those situations are documented at the message.
     */
    sint32 player_number = 2;

    oneof msg {

        // game and player state
        State game_state = 3;
        PlayerElement player_element = 15;
        PlayerElements player_elements = 16;  // above #15; is efficient enough (sets multiple elements) without that saved byte
        GameElements game_elements = 17;

        // board layout and contents
        BoardLayout board_layout = 30;
        PotentialSettlements potential_settlements = 31;
        PieceValue piece_value = 32;
        BuildPiece build_piece = 33;
        CancelBuild cancel_build = 34;
        MovePiece move_piece = 35;
        RemovePiece remove_piece = 36;
        RevealFogHex reveal_fog_hex = 37;

        // turn
        StartGame start_game = 100;
        Turn turn = 101;
        SetTurn set_turn = 102;
        DiceRollRequest dice_roll_request = 103;
        DiceResult dice_result = 104;
        DiceResultResources dice_result_resources = 105;

        // player info

        // player actions
        // (simplerequest = 300)
        // (simpleaction = 301)
        InventoryItemAction inventory_item_action = 302;

        // player actions: trade
        TradeWithBank trade_with_bank = 400;
        TradeMakeOffer trade_make_offer = 401;
        TradeClearOffer trade_clear_offer = 402;
        TradeRejectOffer trade_reject_offer = 403;
        TradeAcceptOffer trade_accept_offer = 404;

        // player actions: resources and robbing
        LoseResources lose_resources_prompt = 500;
        LoseResources lose_resources = 501;
        GainResources gain_resources_prompt = 502;
        GainResources gain_resources = 503;
        ChoosePlayer choose_player_prompt = 504;
        MoveRobber move_robber = 505;

        // game lifecycle: reset board & voting
        ResetBoardRequest reset_board_request = 1000;
        ResetBoardVote reset_board_vote_prompt = 1001;
        ResetBoardVote reset_board_vote = 1002;
        ResetBoardResult reset_board_result = 1003;
    }
}

message GameMessageFromClient {
    string game_name = 1;  // the game; some message types may send special marker {@link SOCMessage#GAME_NONE}

    oneof msg {
        // turn
        StartGame start_game = 100;
        DiceRollRequest dice_roll_request = 101;
        EndTurn end_turn = 102;

        // player actions: buy/build/play pieces and items
        BuildPiece build_piece = 200;
        CancelBuild cancel_build = 201;
        MovePiece move_piece = 202;
        BuyInventoryItemRequest buy_inventory_item = 203;
        InventoryItemAction inventory_item_action = 204;

        // player actions
        // (simplerequest = 300)
        // (simpleaction = 301)

        // player actions: trade
        TradeWithBank trade_with_bank = 400;
        TradeMakeOffer trade_make_offer = 401;
        TradeClearOffer trade_clear_offer = 402;
        TradeRejectOffer trade_reject_offer = 403;
        TradeAcceptOffer trade_accept_offer = 404;

        // player actions: resources and robbing
        LoseResources lose_resources = 500;
        GainResources gain_resources = 501;
        ChooseResourceType choose_resource_type = 502;
        ChoosePlayer choose_player = 503;
        MoveRobber move_robber = 504;

        // game lifecycle: reset board & voting
        ResetBoardRequest reset_board_request = 1000;
        ResetBoardVote reset_board_vote = 1001;
    }
}
